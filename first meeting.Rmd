---
title: "Descriptive plots"
output: html_document
date: "2025-11-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
library(igraph)
library(ggraph)
```

## Descriptive plot to get to know data
### Tomb parameter
Clean the data: 

- create entries for T46, T56, T62 as 1 tomb but with different MNIs (as project partner wants)
- delete irrelevant tomb T47
- impute MNI 20 for T67, and MNI 70 for T46 and T56 as project partner estimated

```{r tp}
tomb_parameter <- read_excel("Data/raw/Statistics project LMU_tomb parameters_Irene Hoegner_new.xlsx", range = "A2:N12")
combined_tombs <- tomb_parameter |> slice(rep(10, 4)) |> mutate(
  "MNI (minimum number of individuals)" = c(250, 300, 350, 400),
  "percentage of successful samples" = `TWIST capture samples included in kinship analysis` / `max number of individuals`,
  `...1` = paste("Elateia T 46,56,62 (MNI ", c(250, 300, 350, 400), ")", sep = ""))
tomb_parameter <- rbind(tomb_parameter, combined_tombs)
tomb_parameter <- tomb_parameter |> rename(Tomb = 1, MNI = 2, `analysed individuals` = 12) |> slice(-c(5, 10)) |> mutate(MNI = as.integer(MNI), `length of use of tomb` = readr::parse_number(`length of use of tomb`),
    `percentage of successful samples` = round(`percentage of successful samples`, 3)
  )
tomb_parameter$MNI[8] <- 20
tomb_parameter$MNI[4] <- 70
tomb_parameter$MNI[6] <- 70
```

The important info in this dataset: "MNI" and "after merging samples from same individual" (**minimum # individuals** vs **actual successful analysed # individual**), since if we don't consider the ratio between them, the result could be bias.

Therefore I create plots of absolute and relative relation of those numbers for every tombs:

``` {r plot tp}
# Absolute plot
df_long <- pivot_longer(tomb_parameter, cols = c(MNI, `analysed individuals`),
                        names_to = "Type", values_to = "Count")
ggplot(df_long, aes(x = Tomb, y = Count, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip()


tomb_parameter |>
  mutate(`not analysed` = MNI - `analysed individuals`) |>
  pivot_longer(cols = c(`not analysed`, `analysed individuals`),
               names_to = "Type", values_to = "Count") |>
  ggplot(aes(x = Tomb, y = Count, fill = Type)) +
  geom_bar(stat = "identity", position = "fill") +
  ylab("Proportion of MNI") +
  scale_y_continuous(labels = scales::percent) +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  coord_flip()

```

Comment:

- Amfissa, Elateia T46 got the most successful analysed ratio
- Based on the absolute plot we get the idea of how big/crowded each tomb is

### Individual metadata
Basic descriptive plots for basic information

Note: filter out Lapoutsi, adding Tombs 46 56 62 as a group

#### Sex 

``` {r im 1}
individual_metadata <- read_excel("Data/raw/Statistics project LMU_individuals metadata_Irene Hoegner.xlsx")
individual_metadata <- individual_metadata |> 
  filter(Site != "Lapoutsi", Tomb %in% c("Amfissa tholos", "Tomb 31", "Tomb 36", "Tomb 46", "Tomb 50", "Tomb 56", "Tomb 62", "Tomb 67")) 

tomb_group_rows <- individual_metadata |>
  filter(Tomb %in% c("Tomb 46", "Tomb 56", "Tomb 62")) |>
  mutate(Tomb = "Tomb 46 56 62")

individual_metadata <- bind_rows(individual_metadata, tomb_group_rows)
  
individual_metadata |> ggplot(mapping = aes(x = Sex, fill = Sex, y = after_stat(prop))) + 
  geom_bar(aes(y = after_stat(count / sum(count))), width = 0.5) +
  theme(legend.position = "none") +
  scale_y_continuous(labels = scales::percent)


individual_metadata |>
  count(Tomb, Sex) |>
  group_by(Tomb) |>
  mutate(prop = n / sum(n)) |>
  ggplot(aes(x = Tomb, y = prop, fill = Sex)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  ylab("Proportion of Sex") +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  coord_flip()
```

Comment:

- Overall there are more analysed male then female
- Different ratio of male and female in each tomb separately
- Just a hypothesis: some tombs might represent family (balanced sex ratio, more related), some tombs use for male dominated group like warrior,... (more male, less related)? (but maybe its not our job to give out specific comment like this)

#### Skeletal element
``` {r im 2}
individual_metadata |>
  count(Tomb, `Skeletal element`) |>
  group_by(Tomb) |>
  mutate(prop = n / sum(n)) |>
  ggplot(aes(x = `Skeletal element`, y = prop, fill = `Skeletal element`)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ Tomb) +
  scale_y_continuous(labels = scales::percent) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none") +
  ylab("Proportion of Skeletal Elements") +
  xlab("Skeletal Element")
```

Comment:

- As explained, petrous bone yields the best preservation of aDNA. Therefore tombs with many petrous bone sample may appear more related solely because of the good DNA preservation. Some might appear less related just because we have less data / less qualified preservation of aDNA.
- **For further improvement**: clean data so that the skeletal element counts every piece of bone seperately. Eg. instead of **1 talus+tooth** we have **1 talus and 1 tooth**. So that the information dont overlapp.(?)

#### Age estimation
``` {r im 3}
individual_metadata |>
  count(Tomb, `Age estimation`) |>
  group_by(Tomb) |>
  mutate(prop = n / sum(n)) |>
  ggplot(aes(x = `Age estimation`, y = prop, fill = `Age estimation`)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ Tomb) +
  scale_y_continuous(labels = scales::percent) +
  theme(legend.position = "none") +
  scale_x_discrete(labels = label_wrap(7)) + 
  ylab("Proportion of Age") +
  xlab("Age estimation")
```

Comment:

- "adult or undefined" is very confusing?? is it high because they are adult or because we dont know??
- adult is more likely to die and get buried (obviously)
- subadult????????
- we could consider it because "age" may correlate with DNA preservation? juveniles may have more fragile bones and therefore could not be analysed, not because they were not buried there?


### Kinship result
Clean data:

- Re-label relationship under threshold
- Extract Individual ID to merge
- Merge together with (original) "Individual metadata" to get the tomb, and tomb parameter for the MNI 
- Filter out Lapoutsi
- group tombs
- potential pairs = MNI*(MNI-1)/2
``` {r kr 1}
kinship_result <- read_excel("Data/raw/Statistics project LMU_READv2 kinship results_Irene Hoegner.xlsx")
og_individual_metadata <- read_excel("Data/raw/Statistics project LMU_individuals metadata_Irene Hoegner.xlsx")

kinship_result <- kinship_result |>
  mutate(Rel = case_when(
    Rel == "First Degree"  & OverlapNSNPs < 500   ~ "Uncertain",
    Rel == "Second Degree" & OverlapNSNPs < 2000  ~ "Uncertain",
    Rel == "Third Degree"  & OverlapNSNPs < 15000 ~ "Uncertain",
    TRUE ~ Rel
  ),
  "Individual1 ID" = substr(Ind1, 1, 6),
  "Individual2 ID" = substr(Ind2, 1, 6)) |>
  left_join(og_individual_metadata, by = c("Individual1 ID" = "Individual ID")) |>
  rename(Tomb1 = Tomb) |>
  left_join(og_individual_metadata, by = c("Individual2 ID" = "Individual ID")) |>
  rename(Tomb2 = Tomb) |> 
  select(names(kinship_result), Tomb1, Tomb2) |>
  mutate(
    "Individual1 ID" = substr(Ind1, 1, 6),
    "Individual2 ID" = substr(Ind2, 1, 6)
  ) |>
  filter(!startsWith(`Ind1`, "LPS") & !startsWith(`Ind2`, "LPS"),
         Tomb1 %in% c("Amfissa tholos", "Tomb 31", "Tomb 36", "Tomb 46", "Tomb 50", "Tomb 56", "Tomb 62", "Tomb 67"),
         Tomb2 %in% c("Amfissa tholos", "Tomb 31", "Tomb 36", "Tomb 46", "Tomb 50", "Tomb 56", "Tomb 62", "Tomb 67")) 

grouped_tombs <- c("Tomb 46", "Tomb 56", "Tomb 62")
group_name <- "Tomb 46 56 62"

kinship_group_pairs <- kinship_result |>
  filter(Tomb1 %in% grouped_tombs | Tomb2 %in% grouped_tombs) |>
  
  # Rename the Tomb columns in the DUPLICATE rows to reflect the new group
  mutate(
    Tomb1 = ifelse(Tomb1 %in% grouped_tombs, group_name, Tomb1),
    Tomb2 = ifelse(Tomb2 %in% grouped_tombs, group_name, Tomb2)
  )

kinship_result <- bind_rows(kinship_result, kinship_group_pairs)


single_tombs <- c("T31", "T36", "T46", "T50", "T56", "T62", "T67")

tomb_parameter <- tomb_parameter |>
  # Create a clean 'JoinKey' column based on the existing 'Tomb' column
  mutate(
    JoinKey = case_when(
      # Case 1: Individual Elateia tombs (e.g., Elateia T31)
      # We extract the number and prepend "Tomb "
      stringr::str_detect(Tomb, "Elateia") & stringr::str_detect(Tomb, paste(single_tombs, collapse = "|")) ~ 
        paste0("Tomb ", stringr::str_extract(Tomb, "\\d+")),
      
      # Case 2: The Amfissa tholos tomb (Exact match)
      Tomb == "Amfissa tholos" ~ "Amfissa tholos",
      
      # Case 3: The consolidated groups (e.g., Elateia T 46,56,62 (MNI 250))
      # This looks for the unique group string you created earlier
      stringr::str_detect(Tomb, "T 46,56,62") ~ "Tomb 46 56 62",
      
      # Default: Keep the original name (or NA if none of the above match)
      TRUE ~ Tomb
    )
  )

# COUNT PAIRS
count_pairs <- kinship_result |> group_by(Tomb1, Tomb2, Rel) |> summarize(num_pairs = n())
internal_relation <- count_pairs[count_pairs$Tomb1 == count_pairs$Tomb2, ]  # 2 Inds inside same tomb
internal_relation
external_relation <- count_pairs[count_pairs$Tomb1 != count_pairs$Tomb2, ]  # 2 Inds inside different tomb
external_relation

# Joining the MNI data into the internal_relation
internal_relation <- internal_relation |>
  left_join(tomb_parameter, by = c("Tomb1" = "JoinKey"), relationship =
  "many-to-many")

internal_relation |>
  group_by(Tomb1) |>
  mutate(
    potential_pairs = (MNI * (MNI - 1)) / 2,
    prop = num_pairs / potential_pairs) |>
  ggplot(aes(x = Rel, y = prop, fill = Rel)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ Tomb1) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent) +
  ylab("Proportion of Pairs") +
  xlab("Relationship")


```

Comment:

- Very low related ratio
- Improvement: Devide binary into "Related" and "Not related"

``` {r kr 2}
binary_kr <- internal_relation |>
  mutate(Rel_group = case_when(
    Rel %in% c("First Degree", "IdenticalTwins/SameIndividual", "Second Degree", "Third Degree") ~ "Related",
    Rel == "Uncertain" ~ "Uncertain",
    Rel %in% c("Unrelated", "Unrelated/Consistent with Third Degree") ~ "Unrelated"
  ))

binary_kr |>
  group_by(Tomb1) |>
  mutate(potential_pairs = (MNI * (MNI - 1)) / 2,
    prop = num_pairs / potential_pairs) |>
  ggplot(aes(x = Rel_group, y = prop, fill = Rel_group)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ Tomb1) +
  theme(legend.position = "none") +
  scale_y_continuous(labels = scales::percent) +
  ylab("Proportion of Pairs") +
  xlab("Relationship")



# TEST NETWORK VISUALIZATION
network_kr <- kinship_result %>% 
  mutate(
    Related = case_when(
      Rel %in% c("First Degree", "IdenticalTwins/SameIndividual", "Second Degree", "Third Degree") ~ TRUE,
      Rel == "Uncertain" ~ FALSE,
      Rel %in% c("Unrelated", "Unrelated/Consistent with Third Degree") ~ NA
    )
  ) %>% 
  filter(Related == TRUE)

edges <- network_kr %>% 
  select(`Individual1 ID`, `Individual2 ID`, Tomb1, Tomb2)

# Create nodes using both columns and their tombs
nodes <- edges %>%
  transmute(name = `Individual1 ID`, Tomb = Tomb1) %>%
  bind_rows(edges %>% transmute(name = `Individual2 ID`, Tomb = Tomb2)) %>%
  distinct(name, .keep_all = TRUE)

# Create graph
g <- graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE)

# Plot
ggraph(g, layout = "fr") + 
  geom_edge_link(color = "grey70") +
  geom_node_point(aes(color = Tomb), size = 3) +
  geom_node_text(aes(label = name), vjust = -1, size = 2) +
  theme_void() +
  scale_color_brewer(palette = "Set2")

# representing the "Related" group proportion (prop).
binary_kr |>
  filter(Rel_group == "Related") |> 
  group_by(Tomb1) |>
  mutate(potential_pairs = (MNI * (MNI - 1)) / 2,
    prop = num_pairs / potential_pairs) |>
  ggplot(aes(x = reorder(Tomb1, prop), y = prop)) +
  geom_col(fill = "#1f77b4") + # Use geom_col for bar height = data value
  coord_flip() + # Flip coordinates to make Tomb names easier to read
  theme_minimal() +
  labs(
    title = "Observed Relatedness as a Ratio of Potential Pairs (by Tomb)",
    x = "Tomb ",
    y = "Observed / Potential Ratio"
  ) +
  scale_y_continuous(labels = scales::percent, expand = expansion(mult = c(0, 0.15))) # Adjust axis for labels



binary_kr |>
  mutate(potential_pairs = (MNI * (MNI - 1)) / 2,
    prop = num_pairs / potential_pairs) |>
  # Reorder the Tomb1 factor based on the proportion of 'Related' pairs for better comparison
  mutate(Tomb1 = forcats::fct_reorder(Tomb1, prop, .fun = sum)) |>
  
  ggplot(aes(x = Tomb1, y = prop, fill = Rel_group)) +
  geom_bar(stat = "identity", position = "stack") + # Stacked bar chart
  coord_flip() + # Flip coordinates for readability
  theme_minimal() +
  labs(
    title = "Composition of Kinship Pairs across Tombs",
    x = "Tomb ID",
    y = "Proportion of Potential Pairs (Observed / Potential)",
    fill = "Relationship Status"
  ) +
  scale_y_continuous(labels = scales::percent) +
  # Custom colors to emphasize 'Related'
  scale_fill_manual(values = c("Related" = "#2ca02c", "Unrelated" = "#ff7f0e", "Uncertain" = "#1f77b4"))
  
```



### PLOT##### 
####sample success rate & length of use####

``` {r plot succes_rate}
tomb_parameter |> 
  ggplot(aes(x = `length of use of tomb`, y = `percentage of successful samples`, label = Tomb)) +
  geom_point(color = "blue", size = 3) +
  geom_text(nudge_y = 0.02, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  theme_minimal() +
  labs(
    title = "Relationship between Length of Use and Sample Success Rate",
    x = "Length of Use (years)",
    y = "Sample Success Rate"
  )
```

## Model
### Research question 1
Develop and validate statistical models to predict the difference between observed and potential relatedness, using tomb parameters (length of use, estimated number of burials, sample success rate) as predictor variables, while accounting for potential confounding factors.


Core idea: ratio model. Model the number of related individuals out of estimated burials (proportion of related individuals):

- Use tomb_parameter, merging the number of related pairs
- Predictors: length of use, proportion of analysed individual 
- confounder: skeletal element (use proportion to eliminating bias causing by absolute number)


``` {r rs1}
related_pairs <- binary_kr |> group_by(Tomb1, Rel_group) |> summarize(sum(num_pairs)) |>
  filter(Rel_group == "Related")
related_pairs

# Now I merge the # related pairs manually
rs1 <- tomb_parameter |> mutate(related_pairs = c(81, 1, 18, 13, 13, 11, 10, 1, rep(82, 4)))
# Create relative number for skeletal element and # analysed individual
rs1 <- rs1 |> mutate(
  prop_petrousbones = `petrous bones` / (`petrous bones` + teeth + `talus/phalanx` + `other`),
  prop_teeth = teeth / (`petrous bones` + teeth + `talus/phalanx` + `other`),
  prop_talus = `talus/phalanx` / (`petrous bones` + teeth + `talus/phalanx` + `other`),
  prop_other = other / (`petrous bones` + teeth + `talus/phalanx` + `other`),
  prop_analysedind = `analysed individuals` / MNI
)
rs1

# Modelling
model1 <- glm(cbind(related_pairs, MNI - related_pairs) ~ `length of use of tomb` + prop_analysedind + prop_petrousbones + prop_teeth + prop_talus + prop_other,
    family = binomial(link = "logit"), data = rs1)
summary(model1)

```


### Research question 2
Build predictive models to estimate relatedness patterns using individual-level covariates (sex, age and skeletal element of sample), considering that some of these factors may be confounded with DNA preservation quality and sampling success


```{r skel_wide}
# Start from the original metadata (with Individual ID & Skeletal element)
skel_long <- og_individual_metadata |>
  select(`Individual ID`, `Skeletal element`) |>
  # Split combinations like "petrous bone+phalanx" into multiple rows
  tidyr::separate_rows(`Skeletal element`, sep = "\\+") |>
  mutate(
    Skel_raw = trimws(`Skeletal element`),
    # Map to a small set of base categories
    Skel_cat = dplyr::case_when(
      grepl("petrous", Skel_raw, ignore.case = TRUE) ~ "petrous",
      grepl("phalanx", Skel_raw, ignore.case = TRUE) ~ "phalanx",
      grepl("talus",   Skel_raw, ignore.case = TRUE) ~ "talus",
      grepl("tooth",   Skel_raw, ignore.case = TRUE) ~ "tooth",
      TRUE ~ "other"
    )
  ) |>
  distinct(`Individual ID`, Skel_cat) |>   # avoid duplicates of same element
  mutate(value = 1L)

# Pivot to wide: one row per individual, columns = skeletal elements (0/1)
skel_wide <- skel_long |>
  tidyr::pivot_wider(
    names_from  = Skel_cat,
    values_from = value,
    values_fill = 0
  )

head(skel_wide)
```


## 2. Clean up age and sex categories (optional but recommended)


```{r clean_age_sex}
og_individual_metadata_clean <- og_individual_metadata |>
  mutate(
    Age_group = dplyr::case_when(
      grepl("adolescent|young adult", `Age estimation`, ignore.case = TRUE) ~ 
        "adolescent_or_young_adult",
      # IMPORTANT: check 'subadult?' first (with escaped ?)
      grepl("subadult\\?", `Age estimation`, ignore.case = TRUE) ~ 
        "subadult_uncertain",
      grepl("subadult", `Age estimation`, ignore.case = TRUE) ~ 
        "subadult",
      grepl("adult", `Age estimation`, ignore.case = TRUE) ~ 
        "adult_or_undefined",
      TRUE ~ "other_or_missing"
    ),
    Age_group = factor(
      Age_group,
      levels = c(
        "adult_or_undefined",
        "adolescent_or_young_adult",
        "subadult",
        "subadult_uncertain",
        "other_or_missing"
      )
    ),
    Sex = factor(Sex)  # XY, YY, etc.
  )

```


## 3. Build pair-level data with skeletal-element columns


```{r rq2_prep_bones}
# Join skeletal-wide and cleaned age/sex info to individuals
indiv_for_join <- og_individual_metadata_clean |>
  left_join(skel_wide, by = "Individual ID")

# Start from kinship_result and make binary outcome
pair_data <- kinship_result |>
  mutate(
    related_binary = dplyr::case_when(
      Rel %in% c("First Degree",
                 "IdenticalTwins/SameIndividual",
                 "Second Degree",
                 "Third Degree") ~ 1L,
      Rel %in% c("Unrelated",
                 "Unrelated/Consistent with Third Degree") ~ 0L,
      TRUE ~ NA_integer_
    )
  ) |>
  # keep only labeled related/unrelated
  filter(!is.na(related_binary)) |>
  # add metadata for individual 1
  left_join(
    indiv_for_join |>
      select(
        `Individual ID`,
        Sex1       = Sex,
        Age_group1 = Age_group,
        Skel_pet1  = petrous,
        Skel_phal1 = phalanx,
        Skel_tal1  = talus,
        Skel_tooth1= tooth,
        Skel_other1= other
      ),
    by = c("Individual1 ID" = "Individual ID")
  ) |>
  # add metadata for individual 2
  left_join(
    indiv_for_join |>
      select(
        `Individual ID`,
        Sex2       = Sex,
        Age_group2 = Age_group,
        Skel_pet2  = petrous,
        Skel_phal2 = phalanx,
        Skel_tal2  = talus,
        Skel_tooth2= tooth,
        Skel_other2= other
      ),
    by = c("Individual2 ID" = "Individual ID")
  ) |>
  # pair-level summary variables
  mutate(
    same_tomb = Tomb1 == Tomb2,
    sex_pair  = paste0(Sex1, "-", Sex2),
    same_sex  = Sex1 == Sex2,
    same_age_group = Age_group1 == Age_group2,

    # counts of each skeletal element in the pair (0, 1, or 2)
    n_petrous = Skel_pet1  + Skel_pet2,
    n_phalanx = Skel_phal1 + Skel_phal2,
    n_talus   = Skel_tal1  + Skel_tal2,
    n_tooth   = Skel_tooth1+ Skel_tooth2,
    n_other   = Skel_other1+ Skel_other2
  )

dplyr::glimpse(pair_data)
```

- `n_petrous`: how many petrous bones in the pair (0/1/2)  
- `n_phalanx`, `n_talus`, `n_tooth`, `n_other` similarly  
- plus sex, age, and same/different tomb flags.

---

## 4. Fit the logistic model with these skeletal-element variables

- same tomb  
- same sex  
- same age group  
- counts of each skeletal element in the pair

```{r rq2_model_bones}
model2_bones <- glm(
  related_binary ~ 
    same_tomb +
    same_sex +
    same_age_group +
    n_petrous + n_phalanx + n_talus + n_tooth + n_other,
  data   = pair_data,
  family = binomial(link = "logit")
)

summary(model2_bones)
```





